# logicOfStatements
Сложность решения:

K = 100 - максимальная длина имени высказывания

T = 100 - максимальное количество операндов в составном высказывании

M = 10000 - максимальное количество составных высказываний

N = 1000000 - максимальное количество простых высказываний

O(K * T * M * log(N + M)) - сложность парсинга всех составных высказываний

O(T ^ 2 * M) - сложность подсчета всех ответов

O(T ^ 2 * M + K * T * M * log(N + M)) - сложность решения

Кратское описание решения:

-Что-бы быстро искать выражения по названию, считав выражение добавляю его в map как пару название и обьект expression соответстувющий этому выражению.

-При парсингу строю обратную польскую нотацию и для каждого составного выражения от которого зависит текущее, добавляю в вектор зависимости dependencies текущее составное выражение.

-При подсчете ответа прохожусь по всем составным выражениям вызывая метод calculate при условии что ответ не подсчитан. Если ответ получается подсчитать, обращаясь к ответам выражений от которых зависит текущее выражение, то для всех выражений, которые зависят от текущего, вызываю метод calculate.

-Суммарно у всех выражений может быть M * T зависимых выражений, т.к. каждое выражение зависит максимум от T выражений, следовательно у T выражений текущее выражении находится в списке зависимых, количество выражений всего M. После перехода к зависимому выражению понадобится O(T) операций на его подсчет, следовательно асимптотика подсчета ответа для всех выражений составит O(T * M * T).
